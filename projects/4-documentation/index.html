<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <div class="wrapper">
      <div class="sidebar">
        <div class="sidebar-title">
          <h1 class="title">GoLang</h1>
        </div>
        <div class="sidebar-content">
          <div class="sidebar-content-title">
            <h2>Documentation</h2>
          </div>
          <div class="sidebar-content-body">
            <ul>
              <li><a href="#introduction" class="button">Introduction</a></li>
              <li>
                <a href="#prerequisites" class="button">Prerequisites</a>
              </li>
              <li>
                <a href="#first-program" class="button">Your first program</a>
              </li>
              <li><a href="#constants" class="button">Constants</a></li>
              <li><a href="#variables" class="button">Variables</a></li>
              <li><a href="#if-statement" class="button">If statement</a></li>
              <li><a href="#for-loop" class="button">For Loop</a></li>
              <li><a href="switch" class="button">Switch</a></li>
              <li><a href="#function" class="button">Functions</a></li>
              <li><a href="#reference" class="button">Reference</a></li>
            </ul>
          </div>
        </div>
      </div>
      <main>
        <section id="introduction">
          <h3 class="section-title">Introduction</h3>
          <div class="section-content">
            <p>
              The Go programming language is an open source project to make
              programmers more productive.
            </p>
            <p>
              Go is expressive, concise, clean, and efficient. Its concurrency
              mechanisms make it easy to write programs that get the most out of
              multicore and networked machines, while its novel type system
              enables flexible and modular program construction. Go compiles
              quickly to machine code yet has the convenience of garbage
              collection and the power of run-time reflection. It's a fast,
              statically typed, compiled language that feels like a dynamically
              typed, interpreted language.
            </p>
          </div>
        </section>
        <section id="prerequisites">
          <h3 class="section-title">Prerequisites</h3>
          <div class="section-content">
            <ul>
              <li>
                <b>Some programming experience.</b> The code here is pretty
                simple, but it helps to know something about functions.
              </li>
              <li>
                <b>A tool to edit your code.</b> Any text editor you have will
                work fine. Most text editors have good support for Go. The most
                popular are VSCode (free), GoLand (paid), and Vim (free).
              </li>
              <li>
                <b>A command terminal.</b> Go works well using any terminal on
                Linux and Mac, and on PowerShell or cmd in Windows.
              </li>
            </ul>
          </div>
        </section>
        <section id="first-program">
          <h3 class="section-title">Your first program</h3>
          <div class="section-content">
            <p>
              To compile and run a simple program, first choose a module path
              (we'll use example/user/hello) and create a go.mod file that
              declares it:
            </p>
            <code>
              <pre>
$ mkdir hello # Alternatively, clone it if it already exists in version control.
$ cd hello
$ go mod init example/user/hello
go: creating new go.mod: module example/user/hello
$ cat go.mod
module example/user/hello

go 1.16
$
              </pre>
            </code>
            <p>
              The first statement in a Go source file must be package name.
              Executable commands must always use package main.
            </p>
            <p>
              Next, create a file named hello.go inside that directory
              containing the following Go code:
            </p>
            <code>
              <pre>
package main

import "fmt"

func main() {
	fmt.Println("Hello, world.")
}
              </pre>
            </code>
            <p>Now you can build and install that program with the go tool:</p>
            <code>
              <pre>
$ go install example/user/hello
$
              </pre>
            </code>
            <p>
              This command builds the hello command, producing an executable
              binary. It then installs that binary as $HOME/go/bin/hello (or,
              under Windows, %USERPROFILE%\go\bin\hello.exe).
            </p>
            <p>
              The install directory is controlled by the GOPATH and GOBIN
              environment variables. If GOBIN is set, binaries are installed to
              that directory. If GOPATH is set, binaries are installed to the
              bin subdirectory of the first directory in the GOPATH list.
              Otherwise, binaries are installed to the bin subdirectory of the
              default GOPATH ($HOME/go or %USERPROFILE%\go).
            </p>
            <p>
              You can use the go env command to portably set the default value
              for an environment variable for future go commands:
            </p>
            <code>
              <pre>
$ go env -w GOBIN=/somewhere/else/bin
$
              </pre>
            </code>
            <p>
              To unset a variable previously set by go env -w, use go env -u:
            </p>

            <code>
              <pre>
$ go env -u GOBIN
$
              </pre>
            </code>
            <p>
              Commands like go install apply within the context of the module
              containing the current working directory. If the working directory
              is not within the example/user/hello module, go install may fail.
            </p>
            <p>
              For convenience, go commands accept paths relative to the working
              directory, and default to the package in the current working
              directory if no other path is given. So in our working directory,
              the following commands are all equivalent:
            </p>
            <code>
              <pre>
$ go install example/user/hello
$ go install .
$ go install
              </pre>
            </code>
            <p>
              Next, let's run the program to ensure it works. For added
              convenience, we'll add the install directory to our PATH to make
              running binaries easy:
            </p>
            <code>
              <pre>
# Windows users should consult https://github.com/golang/go/wiki/SettingGOPATH
# for setting %PATH%.
$ export PATH=$PATH:$(dirname $(go list -f '{{.Target}}' .))
$ hello
Hello, world.
$
              </pre>
            </code>
            <p></p>
          </div>
        </section>
        <section id="constants">
          <h3 class="section-title">Constants</h3>
          <div class="section-content">
            <p>
              Constants in Go are just that—constant. They are created at
              compile time, even when defined as locals in functions, and can
              only be numbers, characters (runes), strings or booleans. Because
              of the compile-time restriction, the expressions that define them
              must be constant expressions, evaluatable by the compiler. For
              instance,
              <code>1&lt;&lt;3</code> is a constant expression, while
              <code>math.Sin(math.Pi/4)</code> is not because the function call
              to <code>math.Sin</code> needs to happen at run time.
            </p>
            <p>
              In Go, enumerated constants are created using the iota enumerator.
              Since iota can be part of an expression and expressions can be
              implicitly repeated, it is easy to build intricate sets of values.
            </p>
            <code>
              <pre>
type ByteSize float64

const (
    _           = iota // ignore first value by assigning to blank identifier
    KB ByteSize = 1 &lt;&lt; (10 * iota)
    MB
    GB
    TB
    PB
    EB
    ZB
    YB
)
              </pre>
            </code>
            <p>
              The ability to attach a method such as String to any user-defined
              type makes it possible for arbitrary values to format themselves
              automatically for printing. Although you'll see it most often
              applied to structs, this technique is also useful for scalar types
              such as floating-point types like ByteSize.
            </p>
            <code>
              <pre>
func (b ByteSize) String() string {
    switch {
    case b >= YB:
        return fmt.Sprintf("%.2fYB", b/YB)
    case b >= ZB:
        return fmt.Sprintf("%.2fZB", b/ZB)
    case b >= EB:
        return fmt.Sprintf("%.2fEB", b/EB)
    case b >= PB:
        return fmt.Sprintf("%.2fPB", b/PB)
    case b >= TB:
        return fmt.Sprintf("%.2fTB", b/TB)
    case b >= GB:
        return fmt.Sprintf("%.2fGB", b/GB)
    case b >= MB:
        return fmt.Sprintf("%.2fMB", b/MB)
    case b >= KB:
        return fmt.Sprintf("%.2fKB", b/KB)
    }
    return fmt.Sprintf("%.2fB", b)
}
              </pre>
            </code>
            <p>
              The expression YB prints as 1.00YB, while ByteSize(1e13) prints as
              9.09TB.
            </p>
            <p>
              The use here of Sprintf to implement ByteSize's String method is
              safe (avoids recurring indefinitely) not because of a conversion
              but because it calls Sprintf with %f, which is not a string
              format: Sprintf will only call the String method when it wants a
              string, and %f wants a floating-point value.
            </p>
          </div>
        </section>
        <section id="variables">
          <h3 class="section-title">Variables</h3>
          <div class="section-content">
            <p>
              Variables can be initialized just like constants but the
              initializer can be a general expression computed at run time.
            </p>
            <code>
              <pre>
var (
    home   = os.Getenv("HOME")
    user   = os.Getenv("USER")
    gopath = os.Getenv("GOPATH")
)
              </pre>
            </code>
          </div>
        </section>
        <section id="if-statement">
          <h3 class="section-title">If statement</h3>
          <div class="section-content">
            <p>In Go a simple if looks like this:</p>
            <code>
              <pre>
if x > 0 {
    return y
}
              </pre>
            </code>
            <p>
              Mandatory braces encourage writing simple if statements on
              multiple lines. It's good style to do so anyway, especially when
              the body contains a control statement such as a return or break.
            </p>
            <p>
              Since if and switch accept an initialization statement, it's
              common to see one used to set up a local variable.
            </p>
            <code>
              <pre>
if err := file.Chmod(0664); err != nil {
    log.Print(err)
    return err
}
              </pre>
            </code>
            <p>
              In the Go libraries, you'll find that when an if statement doesn't
              flow into the next statement—that is, the body ends in break,
              continue, goto, or return—the unnecessary else is omitted.
            </p>
            <code>
              <pre>
f, err := os.Open(name)
if err != nil {
    return err
}
codeUsing(f)
              </pre>
            </code>
            <p>
              This is an example of a common situation where code must guard
              against a sequence of error conditions. The code reads well if the
              successful flow of control runs down the page, eliminating error
              cases as they arise. Since error cases tend to end in return
              statements, the resulting code needs no else statements.
            </p>
            <code>
              <pre>
f, err := os.Open(name)
if err != nil {
    return err
}
d, err := f.Stat()
if err != nil {
    f.Close()
    return err
}
codeUsing(f, d)
              </pre>
            </code>
          </div>
        </section>
        <section id="for-loop">
          <h3 class="section-title">For Loop</h3>
          <div class="section-content">
            <p>
              The Go for loop is similar to—but not the same as—C's. It unifies
              for and while and there is no do-while. There are three forms,
              only one of which has semicolons.
            </p>
            <code>
              <pre>
// Like a C for
for init; condition; post { }

// Like a C while
for condition { }

// Like a C for(;;)
for { }
              </pre>
            </code>
            <p>
              Short declarations make it easy to declare the index variable
              right in the loop.
            </p>
            <code>
              <pre>
sum := 0
for i := 0; i < 10; i++ {
    sum += i
}
              </pre>
            </code>
            <p>
              If you're looping over an array, slice, string, or map, or reading
              from a channel, a range clause can manage the loop.
            </p>
            <code>
              <pre>
for key, value := range oldMap {
    newMap[key] = value
}
              </pre>
            </code>
            <p>
              If you only need the first item in the range (the key or index),
              drop the second:
            </p>
            <code>
              <pre>
for key := range m {
    if key.expired() {
        delete(m, key)
    }
}
              </pre>
            </code>
            <p>
              If you only need the second item in the range (the value), use the
              blank identifier, an underscore, to discard the first:
            </p>
            <code>
              <pre>
sum := 0
for _, value := range array {
    sum += value
}
              </pre>
            </code>
            <p>
              For strings, the range does more work for you, breaking out
              individual Unicode code points by parsing the UTF-8. Erroneous
              encodings consume one byte and produce the replacement rune
              U+FFFD. (The name (with associated builtin type) rune is Go
              terminology for a single Unicode code point. See the language
              specification for details.) The loop
            </p>
            <code>
              <pre>
for pos, char := range "日本\x80語" { // \x80 is an illegal UTF-8 encoding
    fmt.Printf("character %#U starts at byte position %d\n", char, pos)
}
              </pre>
            </code>
            <p>prints</p>
            <code>
              <pre>
character U+65E5 '日' starts at byte position 0
character U+672C '本' starts at byte position 3
character U+FFFD '�' starts at byte position 6
character U+8A9E '語' starts at byte position 7
              </pre>
            </code>
          </div>
        </section>
        <section>
          <h3 class="section-title">Switch statement</h3>
          <div class="section-content">
            <p>
              Go's switch is more general than C's. The expressions need not be
              constants or even integers, the cases are evaluated top to bottom
              until a match is found, and if the switch has no expression it
              switches on true. It's therefore possible—and idiomatic—to write
              an if-else-if-else chain as a switch.
            </p>
            <code>
              <pre>
func unhex(c byte) byte {
    switch {
    case '0' <= c && c <= '9':
        return c - '0'
    case 'a' <= c && c <= 'f':
        return c - 'a' + 10
    case 'A' <= c && c <= 'F':
        return c - 'A' + 10
    }
    return 0
}
              </pre>
            </code>
            <p>
              There is no automatic fall through, but cases can be presented in
              comma-separated lists.
            </p>
            <code>
              <pre>
                func shouldEscape(c byte) bool {
                  switch c {
                  case ' ', '?', '&', '=', '#', '+', '%':
                      return true
                  }
                  return false
              }
              </pre>
            </code>
            <p>
              Although they are not nearly as common in Go as some other C-like
              languages, break statements can be used to terminate a switch
              early. Sometimes, though, it's necessary to break out of a
              surrounding loop, not the switch, and in Go that can be
              accomplished by putting a label on the loop and "breaking" to that
              label. This example shows both uses.
            </p>
            <code>
              <pre>
Loop:
	for n := 0; n < len(src); n += size {
		switch {
		case src[n] < sizeOne:
			if validateOnly {
				break
			}
			size = 1
			update(src[n])

		case src[n] < sizeTwo:
			if n+1 >= len(src) {
				err = errShortInput
				break Loop
			}
			if validateOnly {
				break
			}
			size = 2
			update(src[n] + src[n+1]&lt;&lt;shift)
		}
	}
              </pre>
            </code>
            <p>
              Of course, the continue statement also accepts an optional label
              but it applies only to loops.
            </p>
            <p>
              To close this section, here's a comparison routine for byte slices
              that uses two switch statements:
            </p>
            <code>
              <pre>
// Compare returns an integer comparing the two byte slices,
// lexicographically.
// The result will be 0 if a == b, -1 if a < b, and +1 if a > b
func Compare(a, b []byte) int {
    for i := 0; i < len(a) && i < len(b); i++ {
        switch {
        case a[i] > b[i]:
            return 1
        case a[i] < b[i]:
            return -1
        }
    }
    switch {
    case len(a) > len(b):
        return 1
    case len(a) < len(b):
        return -1
    }
    return 0
}
              </pre>
            </code>
          </div>
        </section>
        <section id="function">
          <h3 class="section-title">Functions</h3>
          <div class="section-content">
            <p>
              One of Go's unusual features is that functions and methods can
              return multiple values. This form can be used to improve on a
              couple of clumsy idioms in C programs: in-band error returns such
              as -1 for EOF and modifying an argument passed by address.
            </p>
            <p>
              In C, a write error is signaled by a negative count with the error
              code secreted away in a volatile location. In Go, Write can return
              a count and an error: “Yes, you wrote some bytes but not all of
              them because you filled the device”. The signature of the Write
              method on files from package os is:
            </p>
            <code>
              <pre>
func (file *File) Write(b []byte) (n int, err error)
              </pre>
            </code>
            <p>
              and as the documentation says, it returns the number of bytes
              written and a non-nil error when n != len(b). This is a common
              style; see the section on error handling for more examples.
            </p>
            <p>
              A similar approach obviates the need to pass a pointer to a return
              value to simulate a reference parameter. Here's a simple-minded
              function to grab a number from a position in a byte slice,
              returning the number and the next position.
            </p>
            <code>
              <pre>
func nextInt(b []byte, i int) (int, int) {
    for ; i < len(b) && !isDigit(b[i]); i++ {
    }
    x := 0
    for ; i < len(b) && isDigit(b[i]); i++ {
        x = x*10 + int(b[i]) - '0'
    }
    return x, i
}
              </pre>
            </code>
            <p>
              You could use it to scan the numbers in an input slice b like
              this:
            </p>
            <code>
              <pre>
for i := 0; i < len(b); {
    x, i = nextInt(b, i)
    fmt.Println(x)
}
              </pre>
            </code>
          </div>
        </section>
        <section id="reference">
          <h3 class="section-title">Reference</h3>
          <div class="section-content">
            <ul>
              <li>
                All the documentation in this page is taken from
                <a href="https://go.dev/doc/effective_go"
                  >Effective GO official docs</a
                >
              </li>
            </ul>
          </div>
        </section>
      </main>
    </div>
  </body>
  <script src="./app.js"></script>
  <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
</html>
